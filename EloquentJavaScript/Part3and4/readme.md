# Часть третья и четвертая
## Функции
Раннее мы уже знакомились с функциями, теперь рассмотрим их подробнее.

Прежде всего функции используются для того, чтоб систематизировать выражения и инструкции, с последующим их повторным применением. То есть в функцию выносят часть кода, которая используется в нескольких местах программы. Это позволяет достаточно просто изменять логику работы программы и отлаживать её выполнение.

### Определение функций
Функции могут определяться двумя способами:
* Записи её в переменную
```javascript
var functionName = function(param1, param2, ...) {
  
}
```
* Обозначение имени после слова `function`
```javascript
function nameFunction(param1, param2, ...) {
  
}
```

### Параметры функции
Как видно из примеров выше, функции могут содержать параметры `param1, param2, ...`, количество параметров не имеет значения, их может быть сколь угодно или не быть вовсе.
 
Используя эти параметры внутри функции мы можем получать выражения которые в них были записаны при вызове функции.

### Область видимости функций
По умолчанию в JavaScript внутри функции видно те переменные, которые доступны снаружи и те, которые были созданы внутри функции. Сначала производится поиск по переменным внутри самой функции, а затем в её окружении. Переменные, выражения и инструкции заданные внутри функции не доступны сранужи, если только функция не возвращает их.

Функции могут содержать вложенные функции, у которых своя область видимости. Также функция может возвращать не какое-то определенное значение, а саму фукнцию (замыкание), это позволяет как бы заморозить выполнение функции до момента пока нам не потребуется значение.

### Стек вызовов функций
Стек вызовов - это последовательность выполнения. Ранее мы уже расматривали, что в JavaScript программа выполняется последовательно сверху вниз. Но что касается функций, то места где-они объявлены, просто пропускаются, до момента пока функция не будет вызвана.

В всязи с особенностями интерпритации языка JavaScript, вызов функции может осуществлятся до её объявления. Иногда это бывает полезно, когда логика работы программмы написана сверху файла.

### Замыкания и рекурсия
Функции как уже было сказано выше могут возвращать другую функцию - замыкания. Также функции могут вызывать сами себя - рекурсию. С рекурсиями надо быть осторожным и всегда указывать условия выхода из рекурсии, иначе легко получить бесконечную рекурсию и переполнение стека - программа просто зависнет и откажется работать.

### Побочные эффекты функций
Кроме возврата значений с помощью зарезервированного слова `return`, функция может создавать побочные действия: показывать уведомления, отсылать запросы на сервер, изменять стили, структуру DOM дерева и т.д..

Также функция может ничего не возвращать или не создавать побочных действи, а также и то и то одновременно.

## Решение задач

Для просмотра результатов необходимо открыть в браузере файл [Exercises.html](Exercises.html)

### Минимум 
Напишите функцию min, принимающую два аргумента, и возвращающую минимальный из них.
```javascript
function min(arg1, arg2) {
       //Если параметр 1 меньше параметра 2
       if (arg1<arg2){
           //То выведем его
           return arg1;
       } else {
           //Иначе выведем второй парметр.
           //По условиям задачи не сказанно, что выводить, если параметры равны, поэтому выведем второе щначение
           return arg2;
       }
   }
```

### Рекурсия
Мы видели, что оператор `%` (остаток от деления) может использоваться для определения того, чётное ли число `( % 2)`. 
А вот ещё один способ определения:
 * Ноль чётный.
 * Единица нечётная. 
 * У любого числа N чётность такая же, как у N - 2.
Напишите рекурсивную функцию isEven согласно этим правилам. Она должна принимать число и возвращать булевское значение. Потестируйте её на 50 и 75. Попробуйте задать ей -1. Почему она ведёт себя таким образом? Можно ли её как-то исправить?

```
   function isEven(number) {
       //Если передано 0, то ситаем его четным и возвращаем true
       if(!number)
           return true;
       
       //Иначе возвращаем остаток от деления, преобразованный к противоположному Boolean встроенной одноименной функцией
       return !Boolean(number % 2)
   }
```
Вызвав прмеры из задачи получили 
```javascript
   console.log(isEven(0)); //true
   console.log(isEven(1)); //false
   console.log(isEven(50)); //true
   console.log(isEven(75)); //false
   console.log(isEven(-1)); //false
```
Видим, что `console.log(isEven(-1));` возвращает `false`, как и поставленно в задаче. Что тут исправлять я не понимаю.

Немного подумав, понимаю, что задачу надо решить иначе используя рекурсию.

```javascript
   function isEven(number) {
       //Если передано 0, то ситаем его четным и возвращаем true
       if (!number)
           return true;

       //Если передана 1, то считаем не четным и возвращаем false
       if (number == 1) {
           return false;
       }

       return isEven(number - 2);
   }
```

Теперь все верно, и при вызове `console.log(isEven(-1));` функция возвращает `Maximum call stack size exceeded`, что означает переполнение стека, поскольку функция не может вернуть 1 или 0. Решается либо отказом от рекурсии, как я решил изначально, или дополнительной проверкой на отрицательность числа, например так:
```javascript
   function isEven(number) {
       //Если передано 0, то ситаем его четным и возвращаем true
       if (!number)
           return true;

       //Если number меньше либо равен 1, то считаем не четным и возвращаем false, для 0 данное выражение не сработает, т.к. мы вернули его раньше, а для всех отрицальных чисел как раз сработает
       if (number >= 1) {
           return false;
       }

       return isEven(number - 2);
   }
```

 
### Считаем бобы
Символ номер N строки можно получить, добавив к ней .charAt(N) ( "строчка".charAt(5) ) – схожим образом с получением длины строки при помощи .length. Возвращаемое значение будет строковым, состоящим из одного символа (к примеру, "к"). У первого символа строки позиция 0, что означает, что у последнего символа позиция будет string.length - 1. Другими словами, у строки из двух символов длина 2, а позиции её символов будут 0 и 1. 

Напишите функцию countBs, которая принимает строку в качестве аргумента, и возвращает количество символов “B”, содержащихся в строке.
```javascript
   function countBs(string) {
       var searchValue = 'B';//Искомый символ
       var count = 0; //счетчик

       //Пройдемся циклом по строчке
       for(var i = 0; i < string.length-1; i++)
       {
           //Если текущая буква сопадает, то увеличим счетчик на 1
           if(string.charAt(i) == searchValue){
               count++;
           }
       }
       return count;
   }
```

Затем напишите функцию countChar, которая работает примерно как countBs, только принимает второй параметр — символ, который мы будем искать в строке (вместо того, чтобы просто считать количество символов “B”). Для этого переделайте функцию countBs.

```javascript
   function countChar(string, searchValue) {
       var count = 0; //счетчик

       //Пройдемся циклом по строчке
       for(var i = 0; i < string.length-1; i++)
       {
           //Если текущая буква сопадает, то увеличим счетчик на 1
           if(string.charAt(i) == searchValue){
               count++;
           }
       }
       return count;
   }
```


 
 
